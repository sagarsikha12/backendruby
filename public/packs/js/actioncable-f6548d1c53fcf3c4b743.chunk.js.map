{"version":3,"sources":["webpack:///./node_modules/@rails/actioncable/src/adapters.js","webpack:///./node_modules/@rails/actioncable/src/logger.js","webpack:///./node_modules/@rails/actioncable/src/connection_monitor.js","webpack:///./node_modules/@rails/actioncable/src/internal.js","webpack:///./node_modules/@rails/actioncable/src/connection.js","webpack:///./node_modules/@rails/actioncable/src/subscription.js","webpack:///./node_modules/@rails/actioncable/src/subscription_guarantor.js","webpack:///./node_modules/@rails/actioncable/src/subscriptions.js","webpack:///./node_modules/@rails/actioncable/src/consumer.js","webpack:///./node_modules/@rails/actioncable/src/index.js"],"names":["logger","self","console","WebSocket","log","this","enabled","_len","arguments","length","messages","Array","_key","push","Date","now","adapters","getTime","secondsSince","time","ConnectionMonitor","constructor","connection","visibilityDidChange","bind","reconnectAttempts","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","staleThreshold","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","getPollInterval","_this$constructor","reconnectionBackoffRate","Math","pow","min","random","connectionIsStale","refreshedAt","disconnectedRecently","reopen","document","visibilityState","isOpen","message_types","protocols","supportedProtocols","slice","indexOf","Connection","consumer","open","subscriptions","monitor","disconnected","send","data","webSocket","JSON","stringify","isActive","getState","socketProtocols","subprotocols","uninstallEventHandlers","url","installEventHandlers","close","undefined","allowReconnect","error","reopenDelay","getProtocol","protocol","isState","triedToReconnect","isProtocolSupported","call","states","state","readyState","toLowerCase","eventName","events","handler","prototype","message","event","_JSON$parse","parse","identifier","reason","reconnect","type","welcome","reconnectAttempted","reload","disconnect","ping","confirmation","confirmSubscription","notify","reconnected","rejection","reject","notifyAll","willAttemptReconnect","Subscription","params","mixin","object","properties","key","value","extend","perform","action","command","unsubscribe","remove","pendingSubscriptions","guarantee","subscription","startGuaranteeing","forget","filter","s","stopGuaranteeing","retrySubscribing","retryTimeout","subscribe","map","Subscriptions","guarantor","create","channelName","channel","add","ensureActiveConnection","findAll","sendCommand","callbackName","args","_len2","_key2","Consumer","_url","createWebSocketURL","connect","addSubProtocol","subprotocol","test","a","createElement","href","replace","createConsumer","getConfig","default_mount_path","name","element","head","querySelector","getAttribute"],"mappings":"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","file":"js/actioncable-f6548d1c53fcf3c4b743.chunk.js","sourcesContent":["export default {\n  logger: self.console,\n  WebSocket: self.WebSocket\n};","import adapters from \"./adapters\";\n\n// The logger is disabled by default. You can enable it with:\n//\n//   ActionCable.logger.enabled = true\n//\n//   Example:\n//\n//   import * as ActionCable from '@rails/actioncable'\n//\n//   ActionCable.logger.enabled = true\n//   ActionCable.logger.log('Connection Established.')\n//\n\nexport default {\n  log() {\n    if (this.enabled) {\n      for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {\n        messages[_key] = arguments[_key];\n      }\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n};","import logger from \"./logger\";\n\n// Responsible for ensuring the cable connection is in good health by validating the heartbeat pings sent from the server, and attempting\n// revival reconnections if things go astray. Internal class, not intended for direct user manipulation.\n\nconst now = () => new Date().getTime();\nconst secondsSince = time => (now() - time) / 1000;\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);\n    }\n  }\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n  recordPing() {\n    this.pingedAt = now();\n  }\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    this.recordPing();\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n\n  // Private\n\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n  poll() {\n    this.pollTimeout = setTimeout(() => {\n      this.reconnectIfStale();\n      this.poll();\n    }, this.getPollInterval());\n  }\n  getPollInterval() {\n    const _this$constructor = this.constructor,\n      staleThreshold = _this$constructor.staleThreshold,\n      reconnectionBackoffRate = _this$constructor.reconnectionBackoffRate;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1.0 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1000 * backoff * (1 + jitter);\n  }\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout(() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }, 200);\n    }\n  }\n}\nConnectionMonitor.staleThreshold = 6; // Server::Connections::BEAT_INTERVAL * 2 (missed two pings)\nConnectionMonitor.reconnectionBackoffRate = 0.15;\nexport default ConnectionMonitor;","export default {\n  \"message_types\": {\n    \"welcome\": \"welcome\",\n    \"disconnect\": \"disconnect\",\n    \"ping\": \"ping\",\n    \"confirmation\": \"confirm_subscription\",\n    \"rejection\": \"reject_subscription\"\n  },\n  \"disconnect_reasons\": {\n    \"unauthorized\": \"unauthorized\",\n    \"invalid_request\": \"invalid_request\",\n    \"server_restart\": \"server_restart\",\n    \"remote\": \"remote\"\n  },\n  \"default_mount_path\": \"/cable\",\n  \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n};","import adapters from \"./adapters\";\nimport ConnectionMonitor from \"./connection_monitor\";\nimport INTERNAL from \"./internal\";\nimport logger from \"./logger\";\n\n// Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.\n\nconst message_types = INTERNAL.message_types,\n  protocols = INTERNAL.protocols;\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\nconst indexOf = [].indexOf;\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      const socketProtocols = [...protocols, ...(this.consumer.subprotocols || [])];\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, socketProtocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n  close() {\n    let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        allowReconnect: true\n      },\n      allowReconnect = _ref.allowReconnect;\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n    // Avoid closing websockets in a \"connecting\" state due to Safari 15.1+ bug. See: https://github.com/rails/rails/issues/43835#issuecomment-1002288478\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n  isOpen() {\n    return this.isState(\"open\");\n  }\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n  triedToReconnect() {\n    return this.monitor.reconnectAttempts > 0;\n  }\n\n  // Private\n\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n  isState() {\n    for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {\n      states[_key] = arguments[_key];\n    }\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n    return null;\n  }\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function () {};\n    }\n  }\n}\nConnection.reopenDelay = 500;\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    const _JSON$parse = JSON.parse(event.data),\n      identifier = _JSON$parse.identifier,\n      message = _JSON$parse.message,\n      reason = _JSON$parse.reason,\n      reconnect = _JSON$parse.reconnect,\n      type = _JSON$parse.type;\n    switch (type) {\n      case message_types.welcome:\n        if (this.triedToReconnect()) {\n          this.reconnectAttempted = true;\n        }\n        this.monitor.recordConnect();\n        return this.subscriptions.reload();\n      case message_types.disconnect:\n        logger.log(`Disconnecting. Reason: ${reason}`);\n        return this.close({\n          allowReconnect: reconnect\n        });\n      case message_types.ping:\n        return this.monitor.recordPing();\n      case message_types.confirmation:\n        this.subscriptions.confirmSubscription(identifier);\n        if (this.reconnectAttempted) {\n          this.reconnectAttempted = false;\n          return this.subscriptions.notify(identifier, \"connected\", {\n            reconnected: true\n          });\n        } else {\n          return this.subscriptions.notify(identifier, \"connected\", {\n            reconnected: false\n          });\n        }\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier);\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\nexport default Connection;","// A new subscription is created through the ActionCable.Subscriptions instance available on the consumer.\n// It provides a number of callbacks and a method for calling remote procedure calls on the corresponding\n// Channel instance on the server side.\n//\n// An example demonstrates the basic functionality:\n//\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\", {\n//     connected() {\n//       // Called once the subscription has been successfully completed\n//     },\n//\n//     disconnected({ willAttemptReconnect: boolean }) {\n//       // Called when the client has disconnected with the server.\n//       // The object will have an `willAttemptReconnect` property which\n//       // says whether the client has the intention of attempting\n//       // to reconnect.\n//     },\n//\n//     appear() {\n//       this.perform('appear', {appearing_on: this.appearingOn()})\n//     },\n//\n//     away() {\n//       this.perform('away')\n//     },\n//\n//     appearingOn() {\n//       $('main').data('appearing-on')\n//     }\n//   })\n//\n// The methods #appear and #away forward their intent to the remote AppearanceChannel instance on the server\n// by calling the `perform` method with the first parameter being the action (which maps to AppearanceChannel#appear/away).\n// The second parameter is a hash that'll get JSON encoded and made available on the server in the data parameter.\n//\n// This is how the server component would look:\n//\n//   class AppearanceChannel < ApplicationActionCable::Channel\n//     def subscribed\n//       current_user.appear\n//     end\n//\n//     def unsubscribed\n//       current_user.disappear\n//     end\n//\n//     def appear(data)\n//       current_user.appear on: data['appearing_on']\n//     end\n//\n//     def away\n//       current_user.away\n//     end\n//   end\n//\n// The \"AppearanceChannel\" name is automatically mapped between the client-side subscription creation and the server-side Ruby class name.\n// The AppearanceChannel#appear/away public methods are exposed automatically to client-side invocation through the perform method.\n\nconst extend = function (object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n  return object;\n};\nexport default class Subscription {\n  constructor(consumer) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let mixin = arguments.length > 2 ? arguments[2] : undefined;\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n\n  // Perform a channel action with the optional data passed as an attribute\n  perform(action) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    data.action = action;\n    return this.send(data);\n  }\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n}","import logger from \"./logger\";\n\n// Responsible for ensuring channel subscribe command is confirmed, retrying until confirmation is received.\n// Internal class, not intended for direct user manipulation.\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n    this.startGuaranteeing();\n  }\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter(s => s !== subscription);\n  }\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n  retrySubscribing() {\n    this.retryTimeout = setTimeout(() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map(subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        });\n      }\n    }, 500);\n  }\n}\nexport default SubscriptionGuarantor;","import Subscription from \"./subscription\";\nimport SubscriptionGuarantor from \"./subscription_guarantor\";\nimport logger from \"./logger\";\n\n// Collection class for creating (and internally managing) channel subscriptions.\n// The only method intended to be triggered by the user is ActionCable.Subscriptions#create,\n// and it should be called through the consumer like so:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n\nexport default class Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n\n  // Private\n\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n  remove(subscription) {\n    this.forget(subscription);\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n    return subscription;\n  }\n  reject(identifier) {\n    return this.findAll(identifier).map(subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    });\n  }\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter(s => s !== subscription);\n    return subscription;\n  }\n  findAll(identifier) {\n    return this.subscriptions.filter(s => s.identifier === identifier);\n  }\n  reload() {\n    return this.subscriptions.map(subscription => this.subscribe(subscription));\n  }\n  notifyAll(callbackName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return this.subscriptions.map(subscription => this.notify(subscription, callbackName, ...args));\n  }\n  notify(subscription, callbackName) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n    let subscriptions;\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [subscription];\n    }\n    return subscriptions.map(subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined);\n  }\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map(subscription => this.guarantor.forget(subscription));\n  }\n  sendCommand(subscription, command) {\n    const identifier = subscription.identifier;\n    return this.consumer.send({\n      command,\n      identifier\n    });\n  }\n}","import Connection from \"./connection\";\nimport Subscriptions from \"./subscriptions\";\n\n// The ActionCable.Consumer establishes the connection to a server-side Ruby Connection object. Once established,\n// the ActionCable.ConnectionMonitor will ensure that its properly maintained through heartbeats and checking for stale updates.\n// The Consumer instance is also the gateway to establishing subscriptions to desired channels through the #createSubscription\n// method.\n//\n// The following example shows how this can be set up:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n//\n// When a consumer is created, it automatically connects with the server.\n//\n// To disconnect from the server, call\n//\n//   App.cable.disconnect()\n//\n// and to restart the connection:\n//\n//   App.cable.connect()\n//\n// Any channel subscriptions which existed prior to disconnecting will\n// automatically resubscribe.\n\nexport default class Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n    this.subprotocols = [];\n  }\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n  send(data) {\n    return this.connection.send(data);\n  }\n  connect() {\n    return this.connection.open();\n  }\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n  addSubProtocol(subprotocol) {\n    this.subprotocols = [...this.subprotocols, subprotocol];\n  }\n}\nexport function createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    // Fix populating Location properties in IE. Otherwise, protocol will be blank.\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}","import Connection from \"./connection\";\nimport ConnectionMonitor from \"./connection_monitor\";\nimport Consumer, { createWebSocketURL } from \"./consumer\";\nimport INTERNAL from \"./internal\";\nimport Subscription from \"./subscription\";\nimport Subscriptions from \"./subscriptions\";\nimport SubscriptionGuarantor from \"./subscription_guarantor\";\nimport adapters from \"./adapters\";\nimport logger from \"./logger\";\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, Subscriptions, SubscriptionGuarantor, adapters, createWebSocketURL, logger };\nexport function createConsumer() {\n  let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getConfig(\"url\") || INTERNAL.default_mount_path;\n  return new Consumer(url);\n}\nexport function getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}"],"sourceRoot":""}